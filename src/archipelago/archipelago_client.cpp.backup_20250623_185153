// archipelago_client.cpp
// Thread-safe WebSocketPP implementation for Archipelago

#include "archipelago_client.h"
#include "../common/engine/printf.h"

// Define ASIO standalone before including WebSocketPP
#define ASIO_STANDALONE
#define _WEBSOCKETPP_CPP11_STL_

// WebSocketPP includes
#include <websocketpp/config/asio_no_tls_client.hpp>
#include <websocketpp/client.hpp>

// JSON handling
#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"

// Standard library includes
#include <iostream>
#include <sstream>
#include <chrono>
#include <thread>
#include <atomic>
#include <condition_variable>
#include <queue>
#include <memory>

// Network includes for hostname resolution
#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
#else
    #include <netdb.h>
    #include <arpa/inet.h>
#endif

// Type definitions
typedef websocketpp::client<websocketpp::config::asio_client> ws_client;
typedef websocketpp::config::asio_client::message_type::ptr message_ptr;
typedef websocketpp::connection_hdl connection_hdl;

namespace Archipelago {

// Global instance
ArchipelagoClient* g_archipelago = nullptr;

// Initialize the Archipelago client system
void AP_Init() {
    if (!g_archipelago) {
        g_archipelago = new ArchipelagoClient();
        Printf("Archipelago: Client initialized\n");
    }
}

// Shutdown the Archipelago client system
void AP_Shutdown() {
    if (g_archipelago) {
        delete g_archipelago;
        g_archipelago = nullptr;
        Printf("Archipelago: Client shutdown\n");
    }
}

// Message structure for thread-safe communication
struct ThreadMessage {
    enum Type {
        CONNECT,
        DISCONNECT,
        SEND,
        RECEIVED
    };
    
    Type type;
    std::string data;
    std::string extra;
    int port;
};

// Private implementation class
class ArchipelagoClient::Impl {
public:
    ws_client m_client;
    connection_hdl m_hdl;
    std::thread m_thread;
    
    // Thread synchronization
    std::atomic<bool> m_running{false};
    std::atomic<bool> m_connected{false};
    std::atomic<ConnectionStatus> m_status{ConnectionStatus::Disconnected};
    
    // Message queues
    std::queue<ThreadMessage> m_toThread;
    std::queue<ThreadMessage> m_fromThread;
    std::mutex m_toThreadMutex;
    std::mutex m_fromThreadMutex;
    
    // Constructor
    Impl() {
        try {
            #ifdef _WIN32
            WSADATA wsaData;
            WSAStartup(MAKEWORD(2, 2), &wsaData);
            #endif
            
            // Set up WebSocket client
            m_client.clear_access_channels(websocketpp::log::alevel::all);
            m_client.clear_error_channels(websocketpp::log::elevel::all);
            
            m_client.init_asio();
            
            // IMPORTANT: Defer handler setup until Connect() to avoid race conditions
            // Handlers will be set up when we actually need them
        } catch (const std::exception& e) {
            Printf("Archipelago: Error initializing: %s\n", e.what());
        }
    }
    
    // Destructor
    ~Impl() {
        StopThread();
        #ifdef _WIN32
        WSACleanup();
        #endif
    }
    
    // Start the worker thread
    void StartThread() {
        if (m_running.exchange(true)) return; // Already running
        
        try {
            m_thread = std::thread([this]() {
                ThreadLoop();
            });
        } catch (const std::exception& e) {
            Printf("Archipelago: Failed to start worker thread: %s\n", e.what());
            m_running = false;
            throw;
        }
    }
    
    // Stop the worker thread
    void StopThread() {
        if (!m_running.exchange(false)) return; // Not running
        
        // Wake up the thread
        m_client.get_io_service().stop();
        
        if (m_thread.joinable()) {
            m_thread.join();
        }
    }
    
    // Main thread loop
    void ThreadLoop() {
        Printf("Archipelago: Worker thread started\n");
        
        while (m_running) {
            try {
                // Process pending messages
                ProcessThreadMessages();
                
                // Run ASIO for a short time
                m_client.get_io_service().reset();
                m_client.get_io_service().run_for(std::chrono::milliseconds(10));
                
                // Small sleep to prevent busy waiting
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                
            } catch (const std::exception& e) {
                Printf("Archipelago: Thread error: %s\n", e.what());
            }
        }
        
        Printf("Archipelago: Worker thread stopped\n");
    }
    
    // Process messages sent to the thread
    void ProcessThreadMessages() {
        std::unique_lock<std::mutex> lock(m_toThreadMutex);
        while (!m_toThread.empty()) {
            ThreadMessage msg = m_toThread.front();
            m_toThread.pop();
            lock.unlock();
            
            switch (msg.type) {
                case ThreadMessage::CONNECT:
                    DoConnect(msg.data, msg.port);
                    break;
                case ThreadMessage::DISCONNECT:
                    DoDisconnect();
                    break;
                case ThreadMessage::SEND:
                    DoSend(msg.data);
                    break;
            }
            
            lock.lock();
        }
    }
    
    // Perform connection
    void DoConnect(const std::string& uri, int port) {
        try {
            websocketpp::lib::error_code ec;
            auto con = m_client.get_connection(uri, ec);
            
            if (ec) {
                Printf("Archipelago: Connection creation failed: %s\n", ec.message().c_str());
                m_status = ConnectionStatus::Error;
                return;
            }
            
            m_hdl = con->get_handle();
            m_client.connect(con);
            
        } catch (const std::exception& e) {
            Printf("Archipelago: Connect error: %s\n", e.what());
            m_status = ConnectionStatus::Error;
        }
    }
    
    // Perform disconnection
    void DoDisconnect() {
        try {
            if (m_connected) {
                websocketpp::lib::error_code ec;
                m_client.close(m_hdl, websocketpp::close::status::going_away, "Client disconnect", ec);
            }
        } catch (...) {
            // Ignore errors during disconnect
        }
    }
    
    // Send a message
    void DoSend(const std::string& message) {
        try {
            if (m_connected) {
                websocketpp::lib::error_code ec;
                m_client.send(m_hdl, message, websocketpp::frame::opcode::text, ec);
                
                if (ec) {
                    Printf("Archipelago: Send error: %s\n", ec.message().c_str());
                } else {
                    Printf("Archipelago: Sent: %s\n", message.c_str());
                }
            }
        } catch (const std::exception& e) {
            Printf("Archipelago: Send exception: %s\n", e.what());
        }
    }
    
    // Connection opened
    void on_open(connection_hdl hdl) {
        m_connected = true;
        m_status = ConnectionStatus::Connected;
        
        // Queue a message for the main thread
        ThreadMessage msg;
        msg.type = ThreadMessage::RECEIVED;
        msg.data = "__CONNECTED__";
        
        std::lock_guard<std::mutex> lock(m_fromThreadMutex);
        m_fromThread.push(msg);
    }
    
    // Connection closed
    void on_close(connection_hdl hdl) {
        m_connected = false;
        m_status = ConnectionStatus::Disconnected;
        
        ThreadMessage msg;
        msg.type = ThreadMessage::RECEIVED;
        msg.data = "__DISCONNECTED__";
        
        std::lock_guard<std::mutex> lock(m_fromThreadMutex);
        m_fromThread.push(msg);
    }
    
    // Connection failed
    void on_fail(connection_hdl hdl) {
        m_connected = false;
        m_status = ConnectionStatus::Error;
        
        ThreadMessage msg;
        msg.type = ThreadMessage::RECEIVED;
        msg.data = "__FAILED__";
        
        std::lock_guard<std::mutex> lock(m_fromThreadMutex);
        m_fromThread.push(msg);
    }
    
    // Message received
    void on_message(connection_hdl hdl, message_ptr msg) {
        if (!msg) {
            Printf("Archipelago: Received null message\n");
            return;
        }
        
        ThreadMessage tmsg;
        tmsg.type = ThreadMessage::RECEIVED;
        tmsg.data = msg->get_payload();
        
        std::lock_guard<std::mutex> lock(m_fromThreadMutex);
        m_fromThread.push(tmsg);
    }
    
    // Send message to thread
    void SendToThread(const ThreadMessage& msg) {
        std::lock_guard<std::mutex> lock(m_toThreadMutex);
        m_toThread.push(msg);
    }
    
    // Get messages from thread
    std::vector<ThreadMessage> GetFromThread() {
        std::vector<ThreadMessage> messages;
        std::lock_guard<std::mutex> lock(m_fromThreadMutex);
        
        while (!m_fromThread.empty()) {
            messages.push_back(m_fromThread.front());
            m_fromThread.pop();
        }
        
        return messages;
    }
};

// Main client constructor
ArchipelagoClient::ArchipelagoClient() 
    : m_impl(std::make_unique<Impl>())
    , m_status(ConnectionStatus::Disconnected)
    , m_port(38281)
    , m_team(0)
    , m_slotId(-1)
    , m_lastReceivedIndex(0) {
    Printf("Archipelago: Client created\n");
}

// Destructor
ArchipelagoClient::~ArchipelagoClient() {
    Disconnect();
    Printf("Archipelago: Client destroyed\n");
}

// Connect to server
bool ArchipelagoClient::Connect(const std::string& host, int port) {
    if (m_status != ConnectionStatus::Disconnected) {
        Printf("Archipelago: Already connected or connecting\n");
        return false;
    }
    
    m_host = host;
    m_port = port;
    
    // Resolve hostname
    std::string resolved_host = host;
    if (host == "localhost") {
        resolved_host = "127.0.0.1";
    }
    
    // Build URI
    std::stringstream uri;
    uri << "ws://" << resolved_host << ":" << port;
    
    Printf("Archipelago: Connecting to %s\n", uri.str().c_str());
    
    // Set up handlers NOW, right before connecting
    m_impl->m_client.set_open_handler([this](connection_hdl hdl) {
        m_impl->on_open(hdl);
    });
    
    m_impl->m_client.set_close_handler([this](connection_hdl hdl) {
        m_impl->on_close(hdl);
    });
    
    m_impl->m_client.set_fail_handler([this](connection_hdl hdl) {
        m_impl->on_fail(hdl);
    });
    
    m_impl->m_client.set_message_handler([this](connection_hdl hdl, message_ptr msg) {
        m_impl->on_message(hdl, msg);
    });
    
    // Start thread if not running
    m_impl->StartThread();
    
    // Send connect message to thread
    ThreadMessage msg;
    msg.type = ThreadMessage::CONNECT;
    msg.data = uri.str();
    msg.port = port;
    m_impl->SendToThread(msg);
    
    m_status = ConnectionStatus::Connecting;
    return true;
}

// Disconnect from server
void ArchipelagoClient::Disconnect() {
    if (m_status == ConnectionStatus::Disconnected) return;
    
    // Send disconnect message to thread
    ThreadMessage msg;
    msg.type = ThreadMessage::DISCONNECT;
    m_impl->SendToThread(msg);
    
    // Give it time to disconnect
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    // Stop thread
    m_impl->StopThread();
    
    m_status = ConnectionStatus::Disconnected;
    m_checkedLocations.clear();
    Printf("Archipelago: Disconnected\n");
}

// Check connection status
bool ArchipelagoClient::IsConnected() const {
    return m_impl->m_connected.load() && 
           (m_status == ConnectionStatus::Connected || m_status == ConnectionStatus::InGame);
}

// Process messages (called from main thread)
void ArchipelagoClient::ProcessMessages() {
    // Get messages from worker thread
    auto messages = m_impl->GetFromThread();
    
    Printf("Archipelago: ProcessMessages - got %d messages\n", (int)messages.size());
    
    for (const auto& msg : messages) {
        if (msg.data == "__CONNECTED__") {
            Printf("Archipelago: WebSocket connected, waiting for RoomInfo\n");
            // Don't send Connect packet yet - wait for RoomInfo
        } else if (msg.data == "__DISCONNECTED__") {
            Printf("Archipelago: Disconnected\n");
            m_status = ConnectionStatus::Disconnected;
        } else if (msg.data == "__FAILED__") {
            Printf("Archipelago: Connection failed\n");
            m_status = ConnectionStatus::Error;
        } else {
            // Regular message
            Printf("Archipelago: Processing message: %s\n", msg.data.c_str());
            HandleMessage(msg.data);
        }
    }
}

// Send packet to server
void ArchipelagoClient::SendPacket(const std::string& json) {
    if (!m_impl->m_connected) {
        Printf("Archipelago: Cannot send - not connected\n");
        return;
    }
    
    ThreadMessage msg;
    msg.type = ThreadMessage::SEND;
    msg.data = json;
    m_impl->SendToThread(msg);
}

// Send initial connect packet
void ArchipelagoClient::SendConnectPacket() {
    Printf("Archipelago: Sending Connect packet\n");
    
    // Archipelago expects an array of packets
    rapidjson::Document doc;
    doc.SetArray();
    auto& allocator = doc.GetAllocator();
    
    rapidjson::Document packet;
    packet.SetObject();
    
    packet.AddMember("cmd", "Connect", allocator);
    packet.AddMember("game", "Selaco", allocator);
    packet.AddMember("name", "Player", allocator);  // Generic name for initial connect
    packet.AddMember("uuid", "selaco-client-001", allocator);
    
    // Update version to match server (0.6.2)
    rapidjson::Value version(rapidjson::kObjectType);
    version.AddMember("class", "Version", allocator);
    version.AddMember("major", 0, allocator);
    version.AddMember("minor", 6, allocator);  // Changed from 4 to 6
    version.AddMember("build", 2, allocator);  // Changed from 0 to 2
    packet.AddMember("version", version, allocator);
    
    packet.AddMember("items_handling", 7, allocator);
    
    rapidjson::Value tags(rapidjson::kArrayType);
    tags.PushBack("AP", allocator);
    packet.AddMember("tags", tags, allocator);
    
    // Add packet to array
    doc.PushBack(packet, allocator);
    
    // Convert to JSON string
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.Accept(writer);
    
    std::string message = buffer.GetString();
    Printf("Archipelago: Connect packet JSON: %s\n", message.c_str());
    SendPacket(message);
}

// Authenticate with server (ConnectSlot)
void ArchipelagoClient::Authenticate(const std::string& slot, const std::string& password, int version) {
    if (m_status != ConnectionStatus::Connected) {
        Printf("Archipelago: Cannot authenticate - not connected (status: %d)\n", (int)m_status);
        return;
    }
    
    Printf("Archipelago: Authenticating as slot: %s\n", slot.c_str());
    m_slot = slot;
    
    // Archipelago expects an array of packets
    rapidjson::Document doc;
    doc.SetArray();
    auto& allocator = doc.GetAllocator();
    
    rapidjson::Document packet;
    packet.SetObject();
    
    packet.AddMember("cmd", "Connect", allocator);
    
    rapidjson::Value slotValue;
    slotValue.SetString(slot.c_str(), allocator);
    packet.AddMember("name", slotValue, allocator);
    
    packet.AddMember("uuid", "selaco-client-001", allocator);
    packet.AddMember("game", "Selaco", allocator);
    
    // Version for Connect packet
    rapidjson::Value ver(rapidjson::kObjectType);
    ver.AddMember("class", "Version", allocator);
    ver.AddMember("major", 0, allocator);
    ver.AddMember("minor", 6, allocator);
    ver.AddMember("build", 2, allocator);
    packet.AddMember("version", ver, allocator);
    
    packet.AddMember("items_handling", 7, allocator);
    
    rapidjson::Value tags(rapidjson::kArrayType);
    tags.PushBack("AP", allocator);
    packet.AddMember("tags", tags, allocator);
    
    if (!password.empty()) {
        rapidjson::Value passValue;
        passValue.SetString(password.c_str(), allocator);
        packet.AddMember("password", passValue, allocator);
    }
    
    // Add packet to array
    doc.PushBack(packet, allocator);
    
    // Convert to JSON string
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.Accept(writer);
    
    std::string message = buffer.GetString();
    Printf("Archipelago: Auth packet JSON: %s\n", message.c_str());
    SendPacket(message);
}

// Send location check
void ArchipelagoClient::SendLocationCheck(int locationId) {
    std::vector<int> locations = { locationId };
    SendLocationChecks(locations);
}

// Send multiple location checks
void ArchipelagoClient::SendLocationChecks(const std::vector<int>& locationIds) {
    if (m_status != ConnectionStatus::InGame) {
        Printf("Archipelago: Cannot send location checks - not in game\n");
        return;
    }
    
    rapidjson::Document doc;
    doc.SetArray();
    auto& allocator = doc.GetAllocator();
    
    rapidjson::Document packet;
    packet.SetObject();
    
    packet.AddMember("cmd", "LocationChecks", allocator);
    
    rapidjson::Value locations(rapidjson::kArrayType);
    for (int id : locationIds) {
        locations.PushBack(id, allocator);
        m_checkedLocations.push_back(id);
    }
    packet.AddMember("locations", locations, allocator);
    
    doc.PushBack(packet, allocator);
    
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.Accept(writer);
    
    SendPacket(buffer.GetString());
}

// Update game status
void ArchipelagoClient::StatusUpdate(const std::string& status) {
    if (m_status != ConnectionStatus::InGame) {
        Printf("Archipelago: Cannot update status - not in game\n");
        return;
    }
    
    rapidjson::Document doc;
    doc.SetArray();
    auto& allocator = doc.GetAllocator();
    
    rapidjson::Document packet;
    packet.SetObject();
    
    packet.AddMember("cmd", "StatusUpdate", allocator);
    
    int statusValue = 0;
    if (status == "READY") statusValue = 10;
    else if (status == "PLAYING") statusValue = 20;
    else if (status == "GOAL") statusValue = 30;
    
    packet.AddMember("status", statusValue, allocator);
    
    doc.PushBack(packet, allocator);
    
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.Accept(writer);
    
    SendPacket(buffer.GetString());
}

// Send ping
void ArchipelagoClient::SendPing() {
    rapidjson::Document doc;
    doc.SetArray();
    auto& allocator = doc.GetAllocator();
    
    rapidjson::Document packet;
    packet.SetObject();
    
    packet.AddMember("cmd", "Bounce", allocator);
    
    rapidjson::Value data(rapidjson::kObjectType);
    data.AddMember("time", 
        std::chrono::system_clock::now().time_since_epoch().count(), allocator);
    packet.AddMember("data", data, allocator);
    
    doc.PushBack(packet, allocator);
    
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.Accept(writer);
    
    SendPacket(buffer.GetString());
    Printf("Archipelago: Ping sent\n");
}

// Handle incoming message
void ArchipelagoClient::HandleMessage(const std::string& message) {
    if (m_messageCallback) {
        m_messageCallback(message);
    }
    
    ParsePacket(message);
}

// Parse packet
void ArchipelagoClient::ParsePacket(const std::string& json) {
    rapidjson::Document doc;
    doc.Parse(json.c_str());
    
    if (doc.HasParseError() || !doc.IsArray() || doc.Empty()) {
        Printf("Archipelago: Invalid packet received\n");
        return;
    }
    
    for (rapidjson::SizeType i = 0; i < doc.Size(); i++) {
        const rapidjson::Value& packet = doc[i];
        
        if (!packet.HasMember("cmd") || !packet["cmd"].IsString()) {
            continue;
        }
        
        std::string cmd = packet["cmd"].GetString();
        
        if (cmd == "RoomInfo") {
            Printf("Archipelago: Received RoomInfo - connection established\n");
            m_status = ConnectionStatus::Connected;
            // Now send the Connect packet
            SendConnectPacket();
            
        } else if (cmd == "Connected") {
            Printf("Archipelago: Slot authentication successful!\n");
            m_status = ConnectionStatus::InGame;
            
            if (packet.HasMember("slot")) {
                m_slotId = packet["slot"].GetInt();
                Printf("  Slot ID: %d\n", m_slotId);
            }
            if (packet.HasMember("team")) {
                m_team = packet["team"].GetInt();
                Printf("  Team: %d\n", m_team);
            }
            if (packet.HasMember("slot_data")) {
                Printf("  Slot data received\n");
            }
            
        } else if (cmd == "ConnectionRefused") {
            Printf("Archipelago: Connection refused!\n");
            if (packet.HasMember("errors") && packet["errors"].IsArray()) {
                for (auto& error : packet["errors"].GetArray()) {
                    if (error.IsString()) {
                        Printf("  Error: %s\n", error.GetString());
                        
                        // Provide helpful messages for common errors
                        if (strcmp(error.GetString(), "InvalidSlot") == 0) {
                            Printf("  The slot name '%s' is not valid for this game.\n", m_slot.c_str());
                            Printf("  Please check the slot name and try again.\n");
                        } else if (strcmp(error.GetString(), "InvalidGame") == 0) {
                            Printf("  The game 'Selaco' is not loaded on the server.\n");
                        }
                    }
                }
            }
            m_status = ConnectionStatus::Error;
            
        } else if (cmd == "ReceivedItems") {
            Printf("Archipelago: Received items\n");
            if (packet.HasMember("index") && packet.HasMember("items")) {
                int index = packet["index"].GetInt();
                const auto& items = packet["items"].GetArray();
                Printf("  Starting at index %d, %d items\n", index, (int)items.Size());
                
                // TODO: Process received items
                if (m_itemReceivedCallback) {
                    for (auto& item : items) {
                        if (item.HasMember("item") && item.HasMember("location") && item.HasMember("player")) {
                            m_itemReceivedCallback(
                                item["item"].GetInt(),
                                item["location"].GetInt(),
                                item["player"].GetInt()
                            );
                        }
                    }
                }
            }
            
        } else if (cmd == "Bounced") {
            Printf("Archipelago: Pong received\n");
            if (packet.HasMember("data") && packet["data"].HasMember("time")) {
                auto sentTime = packet["data"]["time"].GetInt64();
                auto now = std::chrono::system_clock::now().time_since_epoch().count();
                auto latency = (now - sentTime) / 1000000; // Convert to milliseconds
                Printf("  Latency: %lld ms\n", latency);
            }
            
        } else if (cmd == "PrintJSON") {
            Printf("Archipelago: Server message:\n");
            if (packet.HasMember("data") && packet["data"].IsArray()) {
                for (auto& part : packet["data"].GetArray()) {
                    if (part.HasMember("text")) {
                        Printf("  %s", part["text"].GetString());
                    }
                }
                Printf("\n");
            }
            
        } else {
            Printf("Archipelago: Received packet type: %s\n", cmd.c_str());
        }
    }
}

} // namespace Archipelago